name: 'Schema Registry CI/CD with ksr-cli'
description: 'Automate Schema Registry operations in your CI/CD pipeline using the comprehensive ksr-cli tool'
author: 'Roman Melnyk'
branding:
  icon: 'database'
  color: 'blue'

inputs:
  operation:
    description: 'Operation to perform (validate, check-compatibility, deploy, compare, export, lint, generate-docs)'
    required: true
    
  registry-url:
    description: 'Schema Registry URL'
    required: false
    
  registry-type:
    description: 'Type of registry - ksr-cli supports all Confluent-compatible registries'
    required: false
    default: 'confluent'
    
  schemas-path:
    description: 'Path to schema files'
    required: false
    default: './schemas'
    
  schema-file:
    description: 'Single schema file path'
    required: false
    
  subject:
    description: 'Schema subject name'
    required: false
    
  subject-prefix:
    description: 'Prefix to add to all subjects'
    required: false
    default: ''
    
  compatibility-level:
    description: 'Compatibility level (BACKWARD, FORWARD, FULL, NONE)'
    required: false
    default: 'BACKWARD'
    
  schema-type:
    description: 'Schema type (avro, protobuf, json)'
    required: false
    default: 'avro'
    
  output-format:
    description: 'Output format (json, table, markdown)'
    required: false
    default: 'json'
    
  output-path:
    description: 'Output path for exports'
    required: false
    
  fail-on-error:
    description: 'Fail the action on any error'
    required: false
    default: 'true'
    
  dry-run:
    description: 'Perform a dry run without making changes'
    required: false
    default: 'false'
    
  create-subjects:
    description: 'Create subjects if they do not exist'
    required: false
    default: 'true'
    
  normalize-schemas:
    description: 'Normalize schemas before deployment'
    required: false
    default: 'true'
    
  include-versions:
    description: 'Include versions (all, latest)'
    required: false
    default: 'latest'
    
  rules-file:
    description: 'Path to linting rules file'
    required: false
    
  source-registry:
    description: 'Source registry URL for comparison'
    required: false
    
  target-registry:
    description: 'Target registry URL for comparison'
    required: false
    
  auth-method:
    description: 'Authentication method (basic, api-key, oauth)'
    required: false
    default: 'basic'
    
  username:
    description: 'Registry username'
    required: false
    
  password:
    description: 'Registry password'
    required: false
    
  api-key:
    description: 'API key for authentication'
    required: false
    
  api-secret:
    description: 'API secret for authentication'
    required: false
    
  token:
    description: 'OAuth token'
    required: false
    
  debug:
    description: 'Enable debug logging'
    required: false
    default: 'false'
    
  verbose:
    description: 'Enable verbose output'
    required: false
    default: 'false'
    
  cli-version:
    description: 'ksr-cli version to use (e.g., v0.2.3, latest)'
    required: false
    default: 'v0.2.3'

outputs:
  validation-result:
    description: 'Result of schema validation'
    value: ${{ steps.execute.outputs.validation-result }}
    
  compatibility-result:
    description: 'Result of compatibility check'
    value: ${{ steps.execute.outputs.compatibility-result }}
    
  deployed-schemas:
    description: 'List of deployed schemas'
    value: ${{ steps.execute.outputs.deployed-schemas }}
    
  schema-diff:
    description: 'Differences between schemas'
    value: ${{ steps.execute.outputs.schema-diff }}
    
  export-path:
    description: 'Path to exported schemas'
    value: ${{ steps.execute.outputs.export-path }}
    
  operation-status:
    description: 'Status of the operation (success/failure)'
    value: ${{ steps.execute.outputs.operation-status }}
    
  error-message:
    description: 'Error message if operation failed'
    value: ${{ steps.execute.outputs.error-message }}

runs:
  using: 'composite'
  steps:
    - name: Setup ksr-cli (Kafka Schema Registry CLI)
      id: setup
      shell: bash
      run: |
        echo "Setting up ksr-cli (Kafka Schema Registry CLI)..."
        
        # Determine OS and architecture
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)
        
        case $ARCH in
          x86_64)
            ARCH="amd64"
            ;;
          aarch64|arm64)
            ARCH="arm64"
            ;;
          *)
            echo "Unsupported architecture: $ARCH"
            exit 1
            ;;
        esac
        
        # Set CLI version
        CLI_VERSION="${{ inputs.cli-version }}"
        if [ "$CLI_VERSION" == "latest" ]; then
          CLI_VERSION=$(curl -s https://api.github.com/repos/aywengo/ksr-cli/releases/latest | sed -n 's/.*"tag_name": *"\([^"]*\)".*/\1/p')
        fi
        
        # Download ksr-cli binary
        CLI_URL="https://github.com/aywengo/ksr-cli/releases/download/${CLI_VERSION}/ksr-cli_${CLI_VERSION#v}_${OS}_${ARCH}.tar.gz"
        echo "Downloading ksr-cli from: $CLI_URL"
        
        wget -q "$CLI_URL" -O ksr-cli.tar.gz
        tar -xzf ksr-cli.tar.gz
        chmod +x ksr-cli
        sudo mv ksr-cli /usr/local/bin/
        rm ksr-cli.tar.gz
        
        # Verify installation
        ksr-cli --version
        
        # Set up authentication for ksr-cli
        if [ "${{ inputs.auth-method }}" == "basic" ] && [ ! -z "${{ inputs.username }}" ]; then
          echo "Setting up basic authentication for ksr-cli..."
          export KSR_USERNAME="${{ inputs.username }}"
          export KSR_PASSWORD="${{ inputs.password }}"
        elif [ "${{ inputs.auth-method }}" == "api-key" ] && [ ! -z "${{ inputs.api-key }}" ]; then
          echo "Setting up API key authentication for ksr-cli..."
          export KSR_API_KEY="${{ inputs.api-key }}"
          if [ ! -z "${{ inputs.api-secret }}" ]; then
            export KSR_API_SECRET="${{ inputs.api-secret }}"
          fi
        elif [ "${{ inputs.auth-method }}" == "oauth" ] && [ ! -z "${{ inputs.token }}" ]; then
          echo "Setting up OAuth authentication for ksr-cli..."
          export KSR_TOKEN="${{ inputs.token }}"
        fi
        
        # Set registry URL
        if [ ! -z "${{ inputs.registry-url }}" ]; then
          export KSR_REGISTRY_URL="${{ inputs.registry-url }}"
        fi
        
    - name: Execute Operation with ksr-cli
      id: execute
      shell: bash
      run: |
        echo "Executing operation: ${{ inputs.operation }} with ksr-cli"
        
        # Set common CLI options
        CLI_OPTS=""
        
        # Add authentication options
        if [ ! -z "${{ inputs.username }}" ]; then
          CLI_OPTS="$CLI_OPTS --user ${{ inputs.username }} --pass ${{ inputs.password }}"
        elif [ ! -z "${{ inputs.api-key }}" ]; then
          CLI_OPTS="$CLI_OPTS --api-key ${{ inputs.api-key }}"
        fi
        
        # Add registry URL if provided
        if [ ! -z "${{ inputs.registry-url }}" ]; then
          CLI_OPTS="$CLI_OPTS --registry-url ${{ inputs.registry-url }}"
        fi
        
        # Add output format
        if [ ! -z "${{ inputs.output-format }}" ]; then
          CLI_OPTS="$CLI_OPTS --output ${{ inputs.output-format }}"
        fi
        
        # Add debug/verbose flags
        if [ "${{ inputs.debug }}" == "true" ]; then
          export KSR_LOG_LEVEL=debug
        fi
        if [ "${{ inputs.verbose }}" == "true" ]; then
          CLI_OPTS="$CLI_OPTS --verbose"
        fi
        
        # Execute operation using ksr-cli
        case "${{ inputs.operation }}" in
          validate)
            echo "Validating schemas in ${{ inputs.schemas-path }}"
            # Use ksr-cli to validate schemas
            for schema_file in ${{ inputs.schemas-path }}/*.{avsc,json}; do
              if [ -f "$schema_file" ]; then
                echo "Validating $schema_file"
                # Extract subject name from filename
                subject=$(basename "$schema_file" | sed 's/\.[^.]*$//')
                if [ ! -z "${{ inputs.subject-prefix }}" ]; then
                  subject="${{ inputs.subject-prefix }}$subject"
                fi
                
                # Check if schema is valid by attempting to register it with dry-run
                if [ "${{ inputs.dry-run }}" == "true" ]; then
                  echo "Dry run: Would validate schema for subject $subject"
                else
                  ksr-cli check compatibility "$subject" --file "$schema_file" $CLI_OPTS || echo "Schema validation failed for $subject"
                fi
              fi
            done
            ;;
            
          check-compatibility)
            if [ ! -z "${{ inputs.schema-file }}" ] && [ ! -z "${{ inputs.subject }}" ]; then
              echo "Checking compatibility for subject: ${{ inputs.subject }}"
              ksr-cli check compatibility "${{ inputs.subject }}" --file "${{ inputs.schema-file }}" $CLI_OPTS
            else
              echo "Error: Both schema-file and subject are required for compatibility check"
              exit 1
            fi
            ;;
            
          deploy)
            echo "Deploying schemas from ${{ inputs.schemas-path }}"
            if [ "${{ inputs.dry-run }}" == "true" ]; then
              echo "Dry run mode - schemas will not be deployed"
            fi
            
            for schema_file in ${{ inputs.schemas-path }}/*.{avsc,json}; do
              if [ -f "$schema_file" ]; then
                # Extract subject name from filename
                subject=$(basename "$schema_file" | sed 's/\.[^.]*$//')
                if [ ! -z "${{ inputs.subject-prefix }}" ]; then
                  subject="${{ inputs.subject-prefix }}$subject"
                fi
                
                echo "Deploying schema for subject: $subject"
                
                # Set schema type if specified
                schema_type_opt=""
                if [ "${{ inputs.schema-type }}" == "json" ]; then
                  schema_type_opt="--schema-type JSON"
                elif [ "${{ inputs.schema-type }}" == "protobuf" ]; then
                  schema_type_opt="--schema-type PROTOBUF"
                fi
                
                if [ "${{ inputs.dry-run }}" == "false" ]; then
                  ksr-cli create schema "$subject" --file "$schema_file" $schema_type_opt $CLI_OPTS
                else
                  echo "Dry run: Would deploy $schema_file as subject $subject"
                fi
              fi
            done
            ;;
            
          compare)
            echo "Comparing registries is not directly supported by ksr-cli"
            echo "Use export operation on both registries and compare the outputs"
            exit 1
            ;;
            
          export)
            output_path="${{ inputs.output-path }}"
            if [ -z "$output_path" ]; then
              output_path="./exported-schemas.json"
            fi
            
            echo "Exporting schemas to $output_path"
            
            if [ "${{ inputs.include-versions }}" == "all" ]; then
              ksr-cli export subjects --all-versions -f "$output_path" $CLI_OPTS
            else
              ksr-cli export subjects -f "$output_path" $CLI_OPTS
            fi
            
            echo "export-path=$output_path" >> $GITHUB_OUTPUT
            ;;
            
          lint)
            echo "Schema linting with custom rules is not directly supported by ksr-cli"
            echo "ksr-cli performs basic validation during schema operations"
            # Fallback to validation
            echo "Performing basic schema validation instead..."
            for schema_file in ${{ inputs.schemas-path }}/*.{avsc,json}; do
              if [ -f "$schema_file" ]; then
                echo "Validating $schema_file"
                subject=$(basename "$schema_file" | sed 's/\.[^.]*$//')
                ksr-cli check compatibility "$subject" --file "$schema_file" $CLI_OPTS || echo "Validation failed for $schema_file"
              fi
            done
            ;;
            
          generate-docs)
            echo "Documentation generation is not directly supported by ksr-cli"
            echo "Use the export functionality and generate docs from the exported schemas"
            exit 1
            ;;
            
          *)
            echo "Unknown operation: ${{ inputs.operation }}"
            exit 1
            ;;
        esac
        
    - name: Process Results
      if: always()
      shell: bash
      run: |
        # Capture operation status from previous step
        OPERATION_STATUS="${{ steps.execute.outcome }}"
        
        echo "Operation completed with status: $OPERATION_STATUS"
        echo "operation-status=$OPERATION_STATUS" >> $GITHUB_OUTPUT
        
        # Set default values for outputs
        echo "validation-result=" >> $GITHUB_OUTPUT
        echo "compatibility-result=" >> $GITHUB_OUTPUT
        echo "deployed-schemas=" >> $GITHUB_OUTPUT
        echo "schema-diff=" >> $GITHUB_OUTPUT
        
        # Set operation-specific outputs based on the operation performed
        case "${{ inputs.operation }}" in
          validate)
            if [ "$OPERATION_STATUS" == "success" ]; then
              echo "validation-result=All schemas are valid" >> $GITHUB_OUTPUT
            else
              echo "validation-result=Schema validation failed" >> $GITHUB_OUTPUT
              echo "error-message=One or more schemas failed validation" >> $GITHUB_OUTPUT
            fi
            ;;
            
          check-compatibility)
            if [ "$OPERATION_STATUS" == "success" ]; then
              echo "compatibility-result=Schema is compatible" >> $GITHUB_OUTPUT
            else
              echo "compatibility-result=Schema is not compatible" >> $GITHUB_OUTPUT
              echo "error-message=Schema compatibility check failed" >> $GITHUB_OUTPUT
            fi
            ;;
            
          deploy)
            if [ "$OPERATION_STATUS" == "success" ]; then
              # Count deployed schemas
              schema_count=$(find "${{ inputs.schemas-path }}" -name "*.avsc" -o -name "*.json" | wc -l)
              echo "deployed-schemas=Successfully deployed $schema_count schemas" >> $GITHUB_OUTPUT
            else
              echo "deployed-schemas=" >> $GITHUB_OUTPUT
              echo "error-message=Schema deployment failed" >> $GITHUB_OUTPUT
            fi
            ;;
            
          export)
            # export-path is already set in the execute step
            if [ "$OPERATION_STATUS" != "success" ]; then
              echo "error-message=Schema export failed" >> $GITHUB_OUTPUT
            fi
            ;;
            
          *)
            if [ "$OPERATION_STATUS" != "success" ]; then
              echo "error-message=Operation ${{ inputs.operation }} failed" >> $GITHUB_OUTPUT
            fi
            ;;
        esac
        
        # Check if we should fail
        if [ "${{ inputs.fail-on-error }}" == "true" ] && [ "$OPERATION_STATUS" != "success" ]; then
          echo "Operation failed and fail-on-error is enabled!"
          exit 1
        fi